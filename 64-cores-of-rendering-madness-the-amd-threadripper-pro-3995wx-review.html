<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Does 8-Channel Memory Matter? - 64 Cores of Rendering Madness: The AMD Threadripper Pro 3995WX Revie -</title><meta name=robots content="index,follow,noarchive"><meta name=description content="CPU Tests: Microbenchmarks A y-Cruncher Sprint The y-cruncher website has a large amount of benchmark data showing how different CPUs perform when calculating&nbsp;pi up to a given number of digits. Not only are the pi world records present, but below these there are a few CPUs showing the scaling of the hardware, where it shows the time to compute moving from 25 million digits to 50 million, 100 million, 250 million, and all the way up to 10 billion, to showcase how the performance scales with digits (assuming everything is in memory)."><meta name=author content="Martina Birk"><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/app.css><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/an-old-hope.min.css><script defer src=https://assets.cdnweb.info/hugo/paper/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=./theme.png><link rel=icon href=./favicon.ico><link rel=apple-touch-icon href=./apple-touch-icon.png><meta name=generator content="Hugo 0.98.0"><meta property="og:title" content="Does 8-Channel Memory Matter? - 64 Cores of Rendering Madness: The AMD Threadripper Pro 3995WX Revie"><meta property="og:description" content="The y-cruncher website has a large amount of benchmark data showing how different CPUs perform when calculatingpi up to a given number of digits. Not only are the pi world records present, but below these there are a few CPUs showing the scaling of the hardware, where it shows the time to compute moving from"><meta property="og:type" content="article"><meta property="og:url" content="/64-cores-of-rendering-madness-the-amd-threadripper-pro-3995wx-review.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-08-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-30T00:00:00+00:00"><meta itemprop=name content="Does 8-Channel Memory Matter? - 64 Cores of Rendering Madness: The AMD Threadripper Pro 3995WX Revie"><meta itemprop=description content="The y-cruncher website has a large amount of benchmark data showing how different CPUs perform when calculatingpi up to a given number of digits. Not only are the pi world records present, but below these there are a few CPUs showing the scaling of the hardware, where it shows the time to compute moving from"><meta itemprop=datePublished content="2024-08-30T00:00:00+00:00"><meta itemprop=dateModified content="2024-08-30T00:00:00+00:00"><meta itemprop=wordCount content="1132"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Does 8-Channel Memory Matter? - 64 Cores of Rendering Madness: The AMD Threadripper Pro 3995WX Revie"><meta name=twitter:description content="The y-cruncher website has a large amount of benchmark data showing how different CPUs perform when calculatingpi up to a given number of digits. Not only are the pi world records present, but below these there are a few CPUs showing the scaling of the hardware, where it shows the time to compute moving from"></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=./index.html>VibeBlog</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=./sitemap.xml>Sitemap</a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Aug 30, 2024</time>
<span>Martina Birk</span></p><h1>Does 8-Channel Memory Matter? - 64 Cores of Rendering Madness: The AMD Threadripper Pro 3995WX Revie</h1></header><section class=post-content><h2>CPU Tests: Microbenchmarks</h2><h3>A y-Cruncher Sprint</h3><p>The y-cruncher website has a large amount of benchmark data showing how different CPUs perform when calculating&nbsp;pi up to a given number of digits. Not only are the pi world records present, but below these there are a few CPUs showing the scaling of the hardware, where it shows the time to compute moving from 25 million digits to 50 million, 100 million, 250 million, and all the way up to 10 billion, to showcase how the performance scales with digits (assuming everything is in memory). This range of results, from 25 million to 250 billion, is something I’ve dubbed a ‘sprint’.</p><p>I have written some code in order to perform a sprint on every CPU we test. It detects the DRAM, works out the biggest value that can be calculated with that amount of memory, and works up starting from 25 million digits. For the tests that go up to the ~25 billion digits, it only adds an extra 15 minutes to the suite for an 8-core Ryzen CPU. With this test, we can see the effect of increasing memory requirements on the workload and the scaling factor for a workload such as this.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16478/yC%20Sprint_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a><br>Longer lines indicate more memory installed in the system at the time</p><p>For this sprint, we’ve covered each result into how many million digits are calculated per second at each of the dataset sizes. The more cores a system has, the better the compute, and Intel gets an AVX-512 bonus here as well because the software can use AVX-512. But as the dataset gets larger, there is more shuffling of values back and forth between memory and cache, so being able to keep a high bandwidth while also a low latency to all cores is crucial in this test, especially as the test increases.</p><p>The 8-channel 64-core TR Pro 3995WX here does very well, peaking at around 80 million per second, and at the end of the test still being very fast. It sits above the EPYC 7742 here due to the fact that it has a higher TDP and frequency. They are both well above the Threadripper 3990X, which only has quad-channel memory, which is the reason for the decrease as the dataset increases.</p><p>The W-3175X from Intel has the AVX-512 advantage, which is why the 28 cores can compete with the 64 cores from AMD, however the six-channel memory bandwidth and probably the mesh quickly becomes a bottleneck as each core needs to feed those AVX-512 units. This is the sort of situation where in-package HBM is likely to make a big difference. But at the smaller dataset sizes at least the W-3175X can feed enough data across the mesh to the AVX-512 units for the peak throughput.</p><h3>Core-to-Core Latency</h3><p>As the core count of modern CPUs is growing, we are reaching a time when the time to access each core from a different core is no longer a constant. Even before the advent of heterogeneous SoC designs, processors built on large rings or meshes can have different latencies to access the nearest core compared to the furthest core. This rings true especially in multi-socket server environments.</p><p>But modern CPUs, even desktop and consumer CPUs, can have variable access latency to get to another core. For example, in the first generation Threadripper CPUs, we had four chips on the package, each with 8 threads, and each with a different core-to-core latency depending on if it was on-die or off-die. This gets more complex with products like Lakefield, which has two different communication buses depending on which core is talking to which.</p><p>If you are a regular reader of AnandTech’s CPU reviews, you will recognize our Core-to-Core latency test. It’s a great way to show exactly how groups of cores are laid out on the silicon. This is a custom in-house test built by Andrei, and we know there are competing tests out there, but we feel ours is the most accurate to how quick an access between two cores can happen.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16478/3995WX%2064-core%20PING_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Due to a test limitation, we’re only probing the first 64 threads of the system, but the scale out to 128 threads would be identical. This generation of Threadripper Pro is built on Zen 2, similar to Threadripper 3990X and the EPYC 7742, and so we only have quad-core CCXes in play here. A thread speaking to itself has a latency of around 7 nanoseconds, inside a quad-core CCX is around 18-19 nanoseconds, and then accessing any other core varies from 77-89 nanoseconds. Even accessing the CCX on the same chiplet has the same latency, as the communication is designed to ping out to the central IO die first. If Threadripper Pro gets boosted to Zen 3 for the next generation, this will be a big uplift as we’ve already seen with Zen 3. But TR Pro with Zen 3 might only be launched only when Zen 4 comes out, and we’ll be talking about that difference when that happens.</p><h3>Frequency Ramping</h3><p>Both AMD and Intel over the past few years have introduced features to their processors that speed up the time from when a CPU moves from idle into a high powered state. The effect of this means that users can get peak performance quicker, but the biggest knock-on effect for this is with battery life in mobile devices, especially if a system can turbo up quick and turbo down quick, ensuring that it stays in the lowest and most efficient power state for as long as possible.</p><p>Intel’s technology is called SpeedShift, although SpeedShift was not enabled until Skylake.</p><p>One of the issues though with this technology is that sometimes the adjustments in frequency can be so fast, software cannot detect them. If the frequency is changing on the order of microseconds, but your software is only probing frequency in milliseconds (or seconds), then quick changes will be missed. Not only that, as an observer probing the frequency, you could be affecting the actual turbo performance. When the CPU is changing frequency, it essentially has to pause all compute while it aligns the frequency rate of the whole core.</p><p>We wrote an extensive review analysis piece on this, called ‘<a href=#>Reaching for Turbo: Aligning Perception with AMD’s Frequency Metrics</a>’, due to an issue where users were not observing the peak turbo speeds for AMD’s processors.</p><p>We got around the issue by making the frequency probing the workload causing the turbo. The software is able to detect frequency adjustments on a microsecond scale, so we can see how well a system can get to those boost frequencies. Our Frequency Ramp tool has already been in use in a number of reviews.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16478/3995WX%20FreqRamp_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>The frequency ramp here is around one millisecond, indicative of AMD implementing its CPPC2 management design.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZH53gJZxZm9sXZi8s7HSZqafZaKau6Wx0aKloGWdlrGvsdKsZK2glWKurrCMrZ%2BrnZGZv6q8z56pZqiipHp0hZhurrFloprDqrHWaGk%3D</p></section><nav class=post-nav><a class=prev href=./deacon-reese-phillippe.html><span>←</span><span>Deacon Reese Phillippe Biography, Facts &amp;amp; Life Story</span></a>
<a class=next href=./gladiator-1992-1992.html><span>Gladiator (1992) movie review (1992)</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=./></a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>